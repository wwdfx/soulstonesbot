import logging
import psycopg2
import random
from psycopg2.extras import DictCursor
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ApplicationBuilder, CommandHandler, MessageHandler, CallbackQueryHandler, filters, ContextTypes, ConversationHandler, JobQueue
from datetime import datetime, timedelta
import asyncio

# Set up basic logging
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)

# Database connection details
DB_DETAILS = {
    "dbname": "koyebdb",
    "user": "koyeb-adm",
    "password": "WCAFr1R0muaZ",
    "host": "ep-shy-pine-a2e1ouuw.eu-central-1.pg.koyeb.app",
    "port": 5432
}

# Connect to PostgreSQL Database
def connect_db():
    conn = psycopg2.connect(**DB_DETAILS)
    conn.autocommit = True
    return conn

conn = connect_db()
cur = conn.cursor(cursor_factory=DictCursor)

# Function to handle reconnection
def reconnect_db(func):
    async def wrapper(*args, **kwargs):
        global conn, cur
        try:
            return await func(*args, **kwargs)
        except psycopg2.OperationalError:
            conn.close()
            conn = connect_db()
            cur = conn.cursor(cursor_factory=DictCursor)
            return await func(*args, **kwargs)
    return wrapper

# Create tables if they do not exist
cur.execute('''
    CREATE TABLE IF NOT EXISTS balances (
        user_id BIGINT PRIMARY KEY,
        balance INTEGER NOT NULL DEFAULT 0
    )
''')

cur.execute('''
    CREATE TABLE IF NOT EXISTS users (
        user_id BIGINT PRIMARY KEY,
        role TEXT NOT NULL DEFAULT 'user'
    )
''')

cur.execute('''
    CREATE TABLE IF NOT EXISTS last_reading (
        user_id BIGINT PRIMARY KEY,
        last_request TIMESTAMP
    )
''')

cur.execute('''
    CREATE TABLE IF NOT EXISTS checkin_streak (
        user_id BIGINT PRIMARY KEY,
        streak INTEGER NOT NULL DEFAULT 0,
        last_checkin TIMESTAMP
    )
''')

cur.execute('''
    CREATE TABLE IF NOT EXISTS last_game (
        user_id BIGINT PRIMARY KEY,
        last_play TIMESTAMP
    )
''')

cur.execute('''
    CREATE TABLE IF NOT EXISTS missions (
        id SERIAL PRIMARY KEY,
        name TEXT,
        rarity TEXT,
        appearing_rate INTEGER,
        length INTEGER,
        reward INTEGER
    )
''')

cur.execute('''
    CREATE TABLE IF NOT EXISTS user_missions (
        user_id BIGINT,
        mission_id INTEGER,
        start_time TIMESTAMP,
        end_time TIMESTAMP,
        completed BOOLEAN DEFAULT FALSE,
        PRIMARY KEY (user_id, mission_id, start_time)
    )
''')

cur.execute('''
    CREATE TABLE IF NOT EXISTS mission_attempts (
        user_id BIGINT,
        date DATE,
        attempts INTEGER DEFAULT 0,
        PRIMARY KEY (user_id, date)
    )
''')

cur.execute('''
    CREATE TABLE IF NOT EXISTS user_symbols (
        user_id BIGINT PRIMARY KEY,
        symbols_count BIGINT DEFAULT 0
    )
''')

# Populate the missions table with 25 different missions
missions = [
    ('–ü–∞—Ç—Ä—É–ª–∏—Ä–æ–≤–∞—Ç—å –Ω–∏–∂–Ω–∏–π –ë—Ä—É–∫–ª–∏–Ω', '–°–ª–æ–∂–Ω–æ—Å—Ç—å: 1', 50, 2, 150),
    ('–û—Ö—Ä–∞–Ω—è—Ç—å –º–∞–≥–∞ –≤–æ –≤—Ä–µ–º—è —Ä–∏—Ç—É–∞–ª–∞', '–°–ª–æ–∂–Ω–æ—Å—Ç—å: 2', 25, 3, 225),
    ('–ó–∞—á–∏—Å—Ç–∏—Ç—å –Ω–µ–ª–µ–≥–∞–ª—å–Ω–æ–µ –ª–æ–≥–æ–≤–æ –≤–∞–º–ø–∏—Ä–æ–≤', '–°–ª–æ–∂–Ω–æ—Å—Ç—å: 3', 15, 4, 300),
    ('–£–Ω–∏—á—Ç–æ–∂–∏—Ç—å —É–ª–µ–π –¥–µ–º–æ–Ω–æ–≤-—à–µ—Ä—Å—Ç–Ω–µ–π', '–°–ª–æ–∂–Ω–æ—Å—Ç—å: 4', 7, 6, 450),
    ('–£–Ω–∏—á—Ç–æ–∂–∏—Ç—å –≤—ã—Å—à–µ–≥–æ –¥–µ–º–æ–Ω–∞', '–°–ª–æ–∂–Ω–æ—Å—Ç—å: 5', 3, 8, 600),
]

cur.executemany('INSERT INTO missions (name, rarity, appearing_rate, length, reward) VALUES (%s, %s, %s, %s, %s) ON CONFLICT DO NOTHING', missions)
conn.commit()

# Function to retrieve balance
@reconnect_db
async def get_balance(user_id):
    cur.execute('SELECT balance FROM balances WHERE user_id = %s', (user_id,))
    result = cur.fetchone()
    return result['balance'] if result else 0

# Function to update balance
@reconnect_db
async def update_balance(user_id, amount):
    current_balance = await get_balance(user_id)
    new_balance = current_balance + amount
    cur.execute('INSERT INTO balances (user_id, balance) VALUES (%s, %s) ON CONFLICT (user_id) DO UPDATE SET balance = %s', (user_id, new_balance, new_balance))
    conn.commit()
    return new_balance

# Function to reduce balance
@reconnect_db
async def reduce_balance(user_id, amount):
    current_balance = await get_balance(user_id)
    if current_balance < amount:
        return None  # Not enough balance
    new_balance = current_balance - amount
    cur.execute('INSERT INTO balances (user_id, balance) VALUES (%s, %s) ON CONFLICT (user_id) DO UPDATE SET balance = %s', (user_id, new_balance, new_balance))
    conn.commit()
    return new_balance

# Function to set balance
@reconnect_db
async def set_balance(user_id, amount):
    cur.execute('INSERT INTO balances (user_id, balance) VALUES (%s, %s) ON CONFLICT (user_id) DO UPDATE SET balance = %s', (user_id, amount, amount))
    conn.commit()
    return amount

# Function to get user role
@reconnect_db
async def get_user_role(user_id):
    cur.execute('SELECT role FROM users WHERE user_id = %s', (user_id,))
    result = cur.fetchone()
    return result['role'] if result else 'user'

# Function to set user role
@reconnect_db
async def set_user_role(user_id, role):
    cur.execute('INSERT INTO users (user_id, role) VALUES (%s, %s) ON CONFLICT (user_id) DO UPDATE SET role = %s', (user_id, role, role))
    conn.commit()

# Function to get user symbols
@reconnect_db
async def get_user_symbols(user_id):
    cur.execute('SELECT symbols_count FROM user_symbols WHERE user_id = %s', (user_id,))
    result = cur.fetchone()
    return result['symbols_count'] if result else 0

# Function to get user rank
@reconnect_db
async def get_user_rank(user_id):
    symbols_count = await get_user_symbols(user_id)
    
    if symbols_count < 5000:
        return "–°–º–µ—Ä—Ç–Ω—ã–π"
    elif symbols_count < 20000:
        return "–ù–æ–≤–∏—á–æ–∫"
    elif symbols_count < 50000:
        return "–ù–æ–≤–æ–ø—Ä–∏–±—ã–≤—à–∏–π –û—Ö–æ—Ç–Ω–∏–∫"
    elif symbols_count < 100000:
        return "–û–ø—ã—Ç–Ω—ã–π –æ—Ö–æ—Ç–Ω–∏–∫"
    elif symbols_count < 250000:
        return "–õ–∏–¥–µ—Ä –º–∏—Å—Å–∏–π –ò–Ω—Å—Ç–∏—Ç—É—Ç–∞"
    elif symbols_count < 400000:
        return "–õ–∏–¥–µ—Ä –ò–Ω—Å—Ç–∏—Ç—É—Ç–∞"
    elif symbols_count < 250000:
        return "–ö–∞–Ω–¥–∏–¥–∞—Ç –≤ –ò–Ω–∫–≤–∏–∑–∏—Ç–æ—Ä—ã"
    else:
        return "–õ–∏–¥–µ—Ä –ò–Ω—Å—Ç–∏—Ç—É—Ç–∞"

# Image paths
image_paths = {
    1: './check1.png',
    2: './check2.png',
    3: './check3.png',
    4: './check4.png',
    5: './check5.png',
    6: './check6.png',
    7: './check7.png',
    'loss': './lossStreak.png'
}

# Function to handle messages
async def message_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.message:
        message_text = update.message.text
        target_group_id = -1002142915618  # Adjust this ID to your target group

        logger.info(f"Received message in group {update.message.chat_id}: {message_text[:50]}")
        if len(message_text) >= 500 and update.message.chat_id == target_group_id:
            user_id = update.message.from_user.id
            user_mention = update.message.from_user.username or update.message.from_user.first_name
            mention_text = f"@{user_mention}" if update.message.from_user.username else user_mention

            # Update symbols count
            cur.execute('INSERT INTO user_symbols (user_id, symbols_count) VALUES (%s, %s) ON CONFLICT (user_id) DO UPDATE SET symbols_count = user_symbols.symbols_count + %s', (user_id, len(message_text), len(message_text)))
            conn.commit()

            user_rank, soulstones = await get_user_rank(user_id)
            new_balance = await update_balance(user_id, soulstones)
            await update.message.reply_text(f"üíé {mention_text}, –≤–∞—à –ø–æ—Å—Ç –∑–∞—á—Ç—ë–Ω. –í–∞–º –Ω–∞—á–∏—Å–ª–µ–Ω–æ +{soulstones} –∫ –∫–∞–º–Ω—è–º –¥—É—à. –¢–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å: {new_balance}üíé.")

# Function to handle /profile command
async def profile_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    user_mention = update.message.from_user.username or update.message.from_user.first_name
    mention_text = f"@{user_mention}" if update.message.from_user.username else user_mention
    user_rank, _ = await get_user_rank(user_id)
    user_balance = await get_balance(user_id)
    
    total_symbols = await get_user_symbols(user_id)

    profile_text = (f"–ü—Ä–æ—Ñ–∏–ª—å {mention_text}:\n"
                    f"–†–∞–Ω–∫: {user_rank}.\n"
                    f"–ë–∞–ª–∞–Ω—Å –ö–∞–º–Ω–µ–π –¥—É—à: {user_balance}.\n"
                    f"–°–∏–º–≤–æ–ª–æ–≤ –≤ —Ä–ø-—á–∞—Ç–µ: {total_symbols}.")

    buttons = [
        [InlineKeyboardButton("–ë–∞–ª–∞–Ω—Å", callback_data="balance")],
        [InlineKeyboardButton("–ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–µ –æ—Ç –ú–∞–≥–Ω—É—Å–∞", callback_data="reading")],
        [InlineKeyboardButton("–ï–∂–µ–¥–Ω–µ–≤–Ω–∞—è –Ω–∞–≥—Ä–∞–¥–∞", callback_data="checkin")],
        [InlineKeyboardButton("–ö–∞–º–µ–Ω—å-–Ω–æ–∂–Ω–∏—Ü—ã-–±—É–º–∞–≥–∞", callback_data="rockpaperscissors")],
        [InlineKeyboardButton("–ú–∏—Å—Å–∏–∏", callback_data="missions")]
    ]
    keyboard = InlineKeyboardMarkup(buttons)
    await update.message.reply_text(profile_text, reply_markup=keyboard)

# Function to handle /balance command
async def balance_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user_id = query.from_user.id
    user_mention = query.from_user.username or query.from_user.first_name
    mention_text = f"@{user_mention}" if query.from_user.username else user_mention
    balance = await get_balance(user_id)
    await query.edit_message_text(f"üíé {mention_text}, –≤–∞—à —Ç–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å: {balance}üíé.")

# Function to handle the /checkin command
@reconnect_db
async def checkin_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user_id = query.from_user.id
    today = datetime.now()
    cur.execute('SELECT streak, last_checkin FROM checkin_streak WHERE user_id = %s', (user_id,))
    result = cur.fetchone()

    if result:
        streak, last_checkin = result['streak'], result['last_checkin']

        # Check if the user has already checked in today
        if today.date() == last_checkin.date():
            await query.edit_message_text("–í—ã —É–∂–µ –ø–æ–ª—É—á–∞–ª–∏ –Ω–∞–≥—Ä–∞–¥—É –∑–∞ –≤—Ö–æ–¥ —Å–µ–≥–æ–¥–Ω—è. –ü–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–ø—ã—Ç–∫—É –∑–∞–≤—Ç—Ä–∞.")
            return

        # Check if the streak is broken
        if today - last_checkin > timedelta(days=1):
            streak = 1
            reward = 25
            image_path = image_paths['loss']
            await query.message.reply_photo(photo=open(image_path, 'rb'), caption="–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –≤—ã –ø—Ä–µ—Ä–≤–∞–ª–∏ —á–µ—Ä–µ–¥—É –µ–∂–µ–¥–Ω–µ–≤–Ω—ã—Ö –≤—Ö–æ–¥–æ–≤ –∏ –ø–æ–ª—É—á–∏–ª–∏ 25 –ö–∞–º–Ω–µ–π –¥—É—à.")
        else:
            streak += 1
            if streak > 7:
                streak = 7  # Cap streak at 7
            reward = 25 * streak
            image_path = image_paths.get(streak, image_paths[7])  # Default to day 7 image if streak > 7
            await query.message.reply_photo(photo=open(image_path, 'rb'), caption=f"–í—ã –≤—ã–ø–æ–ª–Ω–∏–ª–∏ –µ–∂–µ–¥–Ω–µ–≤–Ω—ã–π –≤—Ö–æ–¥ {streak} –¥–Ω–µ–π –ø–æ–¥—Ä—è–¥ –∏ –ø–æ–ª—É—á–∏–ª–∏ {reward} –ö–∞–º–Ω–µ–π –¥—É—à!")
    else:
        streak = 1
        reward = 25
        image_path = image_paths[1]
        await query.message.reply_photo(photo=open(image_path, 'rb'), caption=f"–í—ã –≤—ã–ø–æ–ª–Ω–∏–ª–∏ –µ–∂–µ–¥–Ω–µ–≤–Ω—ã–π –≤—Ö–æ–¥ 1 –¥–µ–Ω—å –ø–æ–¥—Ä—è–¥ –∏ –ø–æ–ª—É—á–∏–ª–∏ 25 –ö–∞–º–Ω–µ–π –¥—É—à!")

    # Update the last check-in date and streak
    cur.execute('INSERT INTO checkin_streak (user_id, streak, last_checkin) VALUES (%s, %s, %s) ON CONFLICT (user_id) DO UPDATE SET streak = %s, last_checkin = %s', (user_id, streak, today, streak, today))
    conn.commit()

    new_balance = await update_balance(user_id, reward)

    user_mention = query.from_user.username or query.from_user.first_name
    mention_text = f"@{user_mention}" if query.from_user.username else user_mention

    await query.edit_message_text(f"üíé {mention_text}, –≤–∞—à —Ç–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å: {new_balance}üíé.")

# Readings list
readings = [
    "–°–µ–≥–æ–¥–Ω—è –∞–Ω–≥–µ–ª—å—Å–∫–∞—è —Å–∏–ª–∞ –±—É–¥–µ—Ç –Ω–∞–ø—Ä–∞–≤–ª—è—Ç—å —Ç–µ–±—è.",
    "–ù–æ–≤–∞—è —Ä—É–Ω–∞ –æ—Ç–∫—Ä–æ–µ—Ç —Ç–µ–±–µ —Å–≤–æ—é –∏—Å—Ç–∏–Ω–Ω—É—é —Ü–µ–ª—å.",
    "–û—Å—Ç–µ—Ä–µ–≥–∞–π—Å—è –¥–µ–º–æ–Ω–æ–≤, –ø—Ä—è—á—É—â–∏—Ö—Å—è –≤ –Ω–µ–æ–∂–∏–¥–∞–Ω–Ω—ã—Ö –º–µ—Å—Ç–∞—Ö.",
    "–°–æ—é–∑–Ω–∏–∫ –∏–∑ –ù–∏–∂–Ω–µ–≥–æ –º–∏—Ä–∞ –æ–∫–∞–∂–µ—Ç –≤–∞–∂–Ω—É—é –ø–æ–º–æ—â—å.",
    "–¢–≤–æ–π —Å–µ—Ä—Ñ–∏–º—Å–∫–∏–π –∫–ª–∏–Ω–æ–∫ –±—É–¥–µ—Ç —Å–µ–≥–æ–¥–Ω—è —Å–∏—è—Ç—å —è—Ä—á–µ –≤ —Ç–≤–æ–∏—Ö —Ä—É–∫–∞—Ö.",
    "–ò–Ω—Å—Ç–∏—Ç—É—Ç —Ö—Ä–∞–Ω–∏—Ç —Å–µ–∫—Ä–µ—Ç, –∫–æ—Ç–æ—Ä—ã–π –∏–∑–º–µ–Ω–∏—Ç —Ç–≤–æ–π –ø—É—Ç—å.",
    "–°–≤—è–∑—å –ø–∞—Ä–∞–±–∞—Ç–∞–π —É–∫—Ä–µ–ø–∏—Ç —Ç–≤–æ—é —Ä–µ—à–∏–º–æ—Å—Ç—å.",
    "–°–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ –ò–¥—Ä–∏—Å–∞ –ø—Ä–∏–Ω–µ—Å–µ—Ç –≤–∞–∂–Ω—ã–µ –Ω–æ–≤–æ—Å—Ç–∏.",
    "–ú—É–¥—Ä–æ—Å—Ç—å –ë–µ–∑–º–æ–ª–≤–Ω—ã—Ö –±—Ä–∞—Ç—å–µ–≤ –ø–æ–º–æ–∂–µ—Ç –≤ —Ç–≤–æ–µ–º –ø—Ä–∏–∫–ª—é—á–µ–Ω–∏–∏.",
    "–ù–æ–≤–æ–µ –∑–∞–¥–∞–Ω–∏–µ –ø—Ä–æ–≤–µ—Ä–∏—Ç —Ç–≤–æ–∏ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏ –°—É–º–µ—Ä–µ—á–Ω–æ–≥–æ –æ—Ö–æ—Ç–Ω–∏–∫–∞.",
    "–†–µ—à–µ–Ω–∏–µ –ö–æ–Ω–∫–ª–∞–≤–∞ –ø–æ–≤–ª–∏—è–µ—Ç –Ω–∞ —Ç–≤–æ–µ –±—É–¥—É—â–µ–µ.",
    "–ú–∞–≥ –æ—Ç–∫—Ä–æ–µ—Ç —Ç–µ–±–µ –ø–æ—Ä—Ç–∞–ª –≤ –∑–Ω–∞—á–∏–º–æ–µ –º–µ—Å—Ç–æ.",
    "–¢–≤–æ–π —Å—Ç–µ–ª–µ —Å–æ–∑–¥–∞—Å—Ç —Ä—É–Ω—É –æ–≥—Ä–æ–º–Ω–æ–π —Å–∏–ª—ã.",
    "–î—Ä–µ–≤–Ω—è—è –∫–Ω–∏–≥–∞ –∑–∞–∫–ª–∏–Ω–∞–Ω–∏–π –æ—Ç–∫—Ä–æ–µ—Ç –∑–∞–±—ã—Ç–æ–µ –≤—Ä–µ–º–µ–Ω–µ–º –ø—Ä–æ–∫–ª—è—Ç–∏–µ.",
    "–ó–∞–≥–∞–¥–∫–∞ —Ñ–µ–π—Ä–∏ –ø—Ä–∏–≤–µ–¥–µ—Ç —Ç–µ–±—è –∫ —Å–∫—Ä—ã—Ç–æ–π –∏—Å—Ç–∏–Ω–µ.",
    "–¢–≤–æ—è —Å–≤—è–∑—å —Å –∞–Ω–≥–µ–ª—å—Å–∫–∏–º –º–∏—Ä–æ–º —Å—Ç–∞–Ω–µ—Ç —Å–∏–ª—å–Ω–µ–µ.",
    "–õ–æ—è–ª—å–Ω–æ—Å—Ç—å –≤–∞–º–ø–∏—Ä–∞ –æ–∫–∞–∂–µ—Ç—Å—è –Ω–µ–æ—Ü–µ–Ω–∏–º–æ–π.",
    "–ó–∞–∫–ª–∏–Ω–∞–Ω–∏–µ –∫–æ–ª–¥—É–Ω–∞ –ø—Ä–∏–Ω–µ—Å–µ—Ç —è—Å–Ω–æ—Å—Ç—å –≤ –∑–∞–ø—É—Ç–∞–Ω–Ω—É—é —Å–∏—Ç—É–∞—Ü–∏—é.",
    "–î–µ–º–æ–Ω–∏—á–µ—Å–∫–∏–µ –º–∏—Ä—ã –Ω–µ–æ–±—ã—á–∞–π–Ω–æ –∞–∫—Ç–∏–≤–Ω—ã; –±—É–¥—å –Ω–∞ —á–µ–∫—É.",
    "–°–æ–Ω –¥–∞—Å—Ç —Ç–µ–±–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –æ –±—É–¥—É—â–µ–º.",
    "–°–∫—Ä—ã—Ç–∞—è —Ä—É–Ω–∞ –æ—Ç–∫—Ä–æ–µ—Ç –Ω–æ–≤—É—é —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—å.",
    "–ò—â–∏ –æ—Ç–≤–µ—Ç—ã –≤ –ö–æ–¥–µ–∫—Å–µ. –û–Ω –∑–Ω–∞–µ—Ç —á—Ç–æ —Ç–µ–±–µ –ø–æ–¥—Å–∫–∞–∑–∞—Ç—å",
    "–°–º–µ—Ä—Ç–Ω—ã–π —É–¥–∏–≤–∏—Ç —Ç–µ–±—è —Å–≤–æ–µ–π —Ö—Ä–∞–±—Ä–æ—Å—Ç—å—é.",
    "–ü–æ—Ç–µ—Ä—è–Ω–Ω–∞—è —Å–µ–º–µ–π–Ω–∞—è —Ä–µ–ª–∏–∫–≤–∏—è –æ–±—Ä–µ—Ç–µ—Ç –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ.",
    "–¢–µ–Ω–µ–≤–æ–π —Ä—ã–Ω–æ–∫ —Å–æ–¥–µ—Ä–∂–∏—Ç –ø—Ä–µ–¥–º–µ—Ç, –≤–∞–∂–Ω—ã–π –¥–ª—è —Ç–≤–æ–µ–≥–æ –∑–∞–¥–∞–Ω–∏—è.",
    "–°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ —Å –º—è—Ç–µ–∂–Ω—ã–º –°—É–º–µ—Ä–µ—á–Ω—ã–º –æ—Ö–æ—Ç–Ω–∏–∫–æ–º –Ω–µ–∏–∑–±–µ–∂–Ω–æ.",
    "–¶–µ—Ä–µ–º–æ–Ω–∏—è —Ä—É–Ω –ø—Ä–∏–±–ª–∏–∑–∏—Ç —Ç–µ–±—è –∫ —Ç–≤–æ–µ–º—É –∏—Å—Ç–∏–Ω–Ω–æ–º—É –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—É.",
    "–ü–æ—Å–µ—â–µ–Ω–∏–µ –ó–∞–ª–∞ –°–æ–≥–ª–∞—Å–∏—è –æ—á–µ–Ω—å –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ.",
    "–ù–µ–æ–∂–∏–¥–∞–Ω–Ω—ã–π —Å–æ—é–∑ —Å—Ñ–æ—Ä–º–∏—Ä—É–µ—Ç—Å—è —Å –æ–±–∏—Ç–∞—Ç–µ–ª–µ–º –ù–∏–∂–Ω–µ–≥–æ –º–∏—Ä–∞.",
    "–¢–≤–æ–π —Å–µ—Ä—Ñ–∏–º—Å–∫–∏–π –∫–ª–∏–Ω–æ–∫ –ø–æ–º–æ–∂–µ—Ç —É–Ω–∏—á—Ç–æ–∂–∏—Ç—å —Å–∫—Ä—ã—Ç–æ–≥–æ –¥–µ–º–æ–Ω–∞.",
    "–ó–∞–ø—Ä–µ—Ç–Ω–æ–µ –∑–∞–∫–ª–∏–Ω–∞–Ω–∏–µ –±—É–¥–µ—Ç –∏—Å–∫—É—à–∞—Ç—å —Ç–µ–±—è –≤–µ–ª–∏–∫–æ–π —Å–∏–ª–æ–π.",
    "–°–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ –ë–ª–∞–≥–æ–≥–æ –î–≤–æ—Ä–∞ –ø—Ä–∏–±—É–¥–µ—Ç —Å –Ω–∞—Å—Ç–æ—è—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é.",
    "–ü—Ä–∏–∑—Ä–∞–∫ –ø—Ä–æ—à–ª–æ–≥–æ –°—É–º–µ—Ä–µ—á–Ω–æ–≥–æ –æ—Ö–æ—Ç–Ω–∏–∫–∞ –ø—Ä–µ–¥–ª–æ–∂–∏—Ç –º—É–¥—Ä–æ—Å—Ç—å.",
    "–ó–∞—á–∞—Ä–æ–≤–∞–Ω–Ω—ã–π –∞—Ä—Ç–µ—Ñ–∞–∫—Ç —É—Å–∏–ª–∏—Ç —Ç–≤–æ–∏ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏.",
    "–¢–≤–æ—è –ª–æ—è–ª—å–Ω–æ—Å—Ç—å –ö–æ–Ω–∫–ª–∞–≤—É –±—É–¥–µ—Ç –∏—Å–ø—ã—Ç–∞–Ω–∞.",
    "–ü—Ä–æ—Ä–æ—á–µ—Å—Ç–≤–æ –∏–∑ –ú–æ–ª—á–∞–ª–∏–≤–æ–≥–æ –ì–æ—Ä–æ–¥–∞ –≤—ã–π–¥–µ—Ç –Ω–∞ —Å–≤–µ—Ç.",
    "–†–µ–¥–∫–∏–π –¥–µ–º–æ–Ω –ø–æ—Ç—Ä–µ–±—É–µ—Ç —Ç–≤–æ–µ–≥–æ –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ–≥–æ –≤–Ω–∏–º–∞–Ω–∏—è.",
    "–°—Ç–∞—Ä—ã–π –¥—Ä—É–≥ –≤–µ—Ä–Ω–µ—Ç—Å—è —Å —É–¥–∏–≤–∏—Ç–µ–ª—å–Ω—ã–º–∏ –Ω–æ–≤–æ—Å—Ç—è–º–∏.",
    "–í–∏–¥–µ–Ω–∏–µ –æ—Ç –∞–Ω–≥–µ–ª–∞ –†–∞–∑–∏—ç–ª—è –Ω–∞–ø—Ä–∞–≤–∏—Ç —Ç–≤–æ–π –ø—É—Ç—å.",
    "–°–∏–ª–∞ –°–º–µ—Ä—Ç–Ω–æ–π –ß–∞—à–∏ –±—É–¥–µ—Ç –æ—â—É—â–∞—Ç—å—Å—è –æ—Å–æ–±–µ–Ω–Ω–æ —Å–∏–ª—å–Ω–æ —Å–µ–≥–æ–¥–Ω—è.",
    "–ü—É—Ç–µ—à–µ—Å—Ç–≤–∏–µ –≤ –ì–æ—Ä–æ–¥ –ö–æ—Å—Ç–µ–π —Ä–∞—Å–∫—Ä–æ–µ—Ç —Å–∫—Ä—ã—Ç—ã–µ –∑–Ω–∞–Ω–∏—è.",
    "–ó–≤—É–∫ —Ä–æ–≥–∞ –°—É–º–µ—Ä–µ—á–Ω—ã—Ö –æ—Ö–æ—Ç–Ω–∏–∫–æ–≤ —Å–∏–≥–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –≤–∞–∂–Ω–æ–µ —Å–æ–±—ã—Ç–∏–µ.",
    "–¢–∞–∏–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Ä—É–Ω–∞ –ø–æ—è–≤–∏—Ç—Å—è –≤ —Ç–≤–æ–∏—Ö —Å–Ω–∞—Ö.",
    "–í—Å—Ç—Ä–µ—á–∞ —Å –î–≤–æ—Ä–æ–º –°—É–º–µ—Ä–µ–∫ –∏–∑–º–µ–Ω–∏—Ç —Ç–≤–æ—é —Å—É–¥—å–±—É.",
    "–¢–∞–π–Ω–∞ –ò–Ω–∫–≤–∏–∑–∏—Ç–æ—Ä–∞ –±—É–¥–µ—Ç —Ä–∞—Å–∫—Ä—ã—Ç–∞.",
    "–°–∫—Ä—ã—Ç—ã–π –≤—Ö–æ–¥ –≤ –ò–Ω—Å—Ç–∏—Ç—É—Ç –ø—Ä–∏–≤–µ–¥–µ—Ç –∫ –Ω–æ–≤–æ–º—É –æ—Ç–∫—Ä—ã—Ç–∏—é.",
    "–ù–µ–æ–∂–∏–¥–∞–Ω–Ω—ã–π –ø–æ–¥–∞—Ä–æ–∫ –æ—Ç –º–∞–≥–∞ —É–¥–∏–≤–∏—Ç —Ç–µ–±—è.",
    "–¢–∞–π–Ω–æ–µ –ø–æ—Å–ª–∞–Ω–∏–µ –æ—Ç —Ñ–µ–π—Ä–∏ –±—É–¥–µ—Ç –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ.",
    "–û—Ä—É–¥–∏–µ —Å–º–µ—Ä—Ç–∏ —Ä–∞—Å–∫—Ä–æ–µ—Ç —Å–≤–æ—é –∏—Å—Ç–∏–Ω–Ω—É—é —Å–∏–ª—É.",
    "–í–æ—Å—Å—Ç–∞–Ω–∏–µ –°—É–º–µ—Ä–µ—á–Ω—ã—Ö –æ—Ö–æ—Ç–Ω–∏–∫–æ–≤ –Ω–∞ –≥–æ—Ä–∏–∑–æ–Ω—Ç–µ.",
    "–ú—É–¥—Ä–æ—Å—Ç—å –ë–µ–∑–º–æ–ª–≤–Ω—ã—Ö –±—Ä–∞—Ç—å–µ–≤ –∑–∞—â–∏—Ç–∏—Ç —Ç–µ–±—è.",
    "–°—Ç–∞—Ä—ã–π –¥–Ω–µ–≤–Ω–∏–∫ –°—É–º–µ—Ä–µ—á–Ω–æ–≥–æ –æ—Ö–æ—Ç–Ω–∏–∫–∞ —Å–æ–¥–µ—Ä–∂–∞—Ç –∫–ª—é—á –∫ —Ä–∞–∑–≥–∞–¥–∫–µ.",
    "–û–∂–µ—Ä–µ–ª—å–µ –ê–Ω–≥–µ–ª–∞ –∏—Å–ø–æ–ª–Ω–∏—Ç —Å–≤–æ—é –º–∞–≥–∏—é.",
    "–û–∂–∏–¥–∞–π –Ω–µ–æ–∂–∏–¥–∞–Ω–Ω–æ–≥–æ –≥–æ—Å—Ç—è –∏–∑ –ù–∏–∂–Ω–µ–≥–æ –º–∏—Ä–∞.",
    "–î—Ä–µ–≤–Ω–µ–µ –ø—Ä–æ–∫–ª—è—Ç–∏–µ –±—É–¥–µ—Ç —Å–Ω—è—Ç–æ.",
    "–ü–æ—Å–µ—â–µ–Ω–∏–µ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –ò–Ω—Å—Ç–∏—Ç—É—Ç–∞ –æ–±–Ω–∞—Ä—É–∂–∏—Ç –≤–∞–∂–Ω—É—é –ø–æ–¥—Å–∫–∞–∑–∫—É.",
    "–¢–≤–æ—è —Å–≤—è–∑—å —Å –ø–∞—Ä–∞–±–∞—Ç–∞–π –æ–±–µ—Å–ø–µ—á–∏—Ç —Å–∏–ª—É –∏ —è—Å–Ω–æ—Å—Ç—å."
]

# Function to handle the /reading command
@reconnect_db
async def reading_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.callback_query.from_user.id
    if not await can_request_reading(user_id):
        await update.callback_query.edit_message_text("–í—ã —É–∂–µ –∑–∞–ø—Ä–æ—Å–∏–ª–∏ –≥–∞–¥–∞–Ω–∏–µ —Å–µ–≥–æ–¥–Ω—è. –ü–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–ø—ã—Ç–∫—É –∑–∞–≤—Ç—Ä–∞.")
        return

    if await reduce_balance(user_id, 50) is None:
        await update.callback_query.edit_message_text("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ö–∞–º–Ω–µ–π –î—É—à –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞ –≥–∞–¥–∞–Ω–∏—è.")
        return

    await update.callback_query.message.reply_text("–ö–∞–º–Ω–∏ –¥—É—à —Å –ª—ë–≥–∫–∏–º —Ç—Ä–µ—Å–∫–æ–º –æ—Å—ã–ø–∞–ª–∏—Å—å –Ω–∞ —Å—Ç–æ–ª. –ú–∞–≥–Ω—É—Å –≤—Å–∫–∏–Ω—É–ª –Ω–∞ –Ω–∏—Ö —Å–≤–æ–π –≤–∑–æ—Ä, —É–ª—ã–±–Ω—É–ª—Å—è –∏ –ø–æ–ª–æ–∂–∏–ª —Ä—É–∫—É –Ω–∞ —Ö—Ä—É—Å—Ç–∞–ª—å–Ω—ã–π —à–∞—Ä...")
    await asyncio.sleep(2)

    reading = random.choice(readings)
    await update.callback_query.message.reply_photo(photo=open('./reading.png', 'rb'), caption=f"–í–∞—à–µ –≥–∞–¥–∞–Ω–∏–µ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è:\n\n{reading}")

# Function to check and update last reading request time
@reconnect_db
async def can_request_reading(user_id):
    cur.execute('SELECT last_request FROM last_reading WHERE user_id = %s', (user_id,))
    result = cur.fetchone()
    if result:
        last_request_time = result['last_request']
        if datetime.now() - last_request_time < timedelta(days=1):
            return False
    cur.execute('INSERT INTO last_reading (user_id, last_request) VALUES (%s, %s) ON CONFLICT (user_id) DO UPDATE SET last_request = %s', (user_id, datetime.now(), datetime.now()))
    conn.commit()
    return True

# Function to handle the /rockpaperscissors command
@reconnect_db
async def rockpaperscissors_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user_id = query.from_user.id
    cur.execute('SELECT last_play FROM last_game WHERE user_id = %s', (user_id,))
    result = cur.fetchone()
    now = datetime.now()

    if result:
        last_play = result['last_play']
        if now - last_play < timedelta(minutes=10):
            await query.edit_message_text("–í—ã –º–æ–∂–µ—Ç–µ –∏–≥—Ä–∞—Ç—å —Ç–æ–ª—å–∫–æ —Ä–∞–∑ –≤ 10 –º–∏–Ω—É—Ç. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.")
            return

    buttons = [
        InlineKeyboardButton("25", callback_data="bet_25"),
        InlineKeyboardButton("50", callback_data="bet_50"),
        InlineKeyboardButton("100", callback_data="bet_100"),
        InlineKeyboardButton("200", callback_data="bet_200"),
        InlineKeyboardButton("500", callback_data="bet_500")
    ]
    keyboard = InlineKeyboardMarkup.from_column(buttons)
    await query.edit_message_text("–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ö–∞–º–Ω–µ–π –¥—É—à, –∫–æ—Ç–æ—Ä—ã–µ –≤—ã —Ö–æ—Ç–∏—Ç–µ –ø–æ—Å—Ç–∞–≤–∏—Ç—å:", reply_markup=keyboard)

@reconnect_db
async def bet_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id
    bet = int(query.data.split('_')[1])
    balance = await get_balance(user_id)

    if balance < bet:
        await query.edit_message_text("–£ –≤–∞—Å –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ö–∞–º–Ω–µ–π –¥—É—à –¥–ª—è —ç—Ç–æ–π —Å—Ç–∞–≤–∫–∏.")
        return

    buttons = [
        InlineKeyboardButton("ü™®", callback_data=f"play_{bet}_rock"),
        InlineKeyboardButton("üìÑ", callback_data=f"play_{bet}_paper"),
        InlineKeyboardButton("‚úÇÔ∏è", callback_data=f"play_{bet}_scissors")
    ]
    keyboard = InlineKeyboardMarkup.from_row(buttons)
    await query.edit_message_text("–í—ã–±–µ—Ä–∏—Ç–µ, —á—Ç–æ –≤—ã —Ö–æ—Ç–∏—Ç–µ –≤—ã–±—Ä–æ—Å–∏—Ç—å:", reply_markup=keyboard)

@reconnect_db
async def play_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id
    bet, user_choice = query.data.split('_')[1:]
    bet = int(bet)
    choices = ['rock', 'paper', 'scissors']
    bot_choice = random.choice(choices)

    outcomes = {
        ('rock', 'scissors'): "win",
        ('rock', 'paper'): "lose",
        ('paper', 'rock'): "win",
        ('paper', 'scissors'): "lose",
        ('scissors', 'paper'): "win",
        ('scissors', 'rock'): "lose"
    }

    if user_choice == bot_choice:
        result = "draw"
    else:
        result = outcomes.get((user_choice, bot_choice))

    if result == "win":
        new_balance = await update_balance(user_id, bet)
        await query.edit_message_text(f"–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã –≤—ã–∏–≥—Ä–∞–ª–∏ {bet} –ö–∞–º–Ω–µ–π –¥—É—à. –í–∞—à —Ç–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å: {new_balance}üíé.")
    elif result == "lose":
        new_balance = await update_balance(user_id, -bet)
        await query.edit_message_text(f"–í—ã –ø—Ä–æ–∏–≥—Ä–∞–ª–∏ {bet} –ö–∞–º–Ω–µ–π –¥—É—à. –í–∞—à —Ç–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å: {new_balance}üíé.")
    else:
        await query.edit_message_text(f"–ù–∏—á—å—è! –í–∞—à –±–∞–ª–∞–Ω—Å –æ—Å—Ç–∞–ª—Å—è –ø—Ä–µ–∂–Ω–∏–º: {await get_balance(user_id)}üíé.")

    # Update the last play time
    now = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    cur.execute('INSERT INTO last_game (user_id, last_play) VALUES (%s, %s) ON CONFLICT (user_id) DO UPDATE SET last_play = %s', (user_id, now, now))
    conn.commit()

# Function to handle /addbalance command (admin only)
@reconnect_db
async def add_balance_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    if await get_user_role(user_id) != 'admin':
        await update.message.reply_text("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã.")
        return

    if len(context.args) != 2:
        await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /addbalance <user_id> <amount>")
        return

    target_user_id, amount = context.args
    try:
        amount = int(amount)
    except ValueError:
        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ —á–∏—Å–ª–æ.")
        return

    new_balance = await update_balance(int(target_user_id), amount)
    await update.message.reply_text(f"–ë–∞–ª–∞–Ω—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {target_user_id} —É–≤–µ–ª–∏—á–µ–Ω –Ω–∞ {amount} –ö–∞–º–Ω–µ–π –¥—É—à. –ù–æ–≤—ã–π –±–∞–ª–∞–Ω—Å: {new_balance}üíé.")

# Function to handle /subbalance command (admin only)
@reconnect_db
async def sub_balance_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    if await get_user_role(user_id) != 'admin':
        await update.message.reply_text("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã.")
        return

    if len(context.args) != 2:
        await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /subbalance <user_id> <amount>")
        return

    target_user_id, amount = context.args
    try:
        amount = int(amount)
    except ValueError:
        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ —á–∏—Å–ª–æ.")
        return

    new_balance = await reduce_balance(int(target_user_id), amount)
    if new_balance is None:
        await update.message.reply_text("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ö–∞–º–Ω–µ–π –¥—É—à –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –æ–ø–µ—Ä–∞—Ü–∏–∏.")
        return

    await update.message.reply_text(f"–ë–∞–ª–∞–Ω—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {target_user_id} —É–º–µ–Ω—å—à–µ–Ω –Ω–∞ {amount} –ö–∞–º–Ω–µ–π –¥—É—à. –ù–æ–≤—ã–π –±–∞–ª–∞–Ω—Å: {new_balance}üíé.")

# Function to handle /setbalance command (admin only)
@reconnect_db
async def set_balance_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.message.from_user.id
    if await get_user_role(user_id) != 'admin':
        await update.message.reply_text("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã.")
        return

    if len(context.args) != 2:
        await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /setbalance <user_id> <amount>")
        return

    target_user_id, amount = context.args
    try:
        amount = int(amount)
    except ValueError:
        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ —á–∏—Å–ª–æ.")
        return

    new_balance = await set_balance(int(target_user_id), amount)
    await update.message.reply_text(f"–ë–∞–ª–∞–Ω—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {target_user_id} —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –Ω–∞ {amount} –ö–∞–º–Ω–µ–π –¥—É—à. –ù–æ–≤—ã–π –±–∞–ª–∞–Ω—Å: {new_balance}üíé.")

# Conversation states
PROMOTE_USER_ID = range(1)

# Function to handle /promote command (super admin only)
@reconnect_db
async def promote_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    super_admin_id = 6505061807  # Replace with your actual super admin ID
    user_id = update.message.from_user.id

    if user_id != super_admin_id:
        await update.message.reply_text("–£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–∞–≤ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã.")
        return ConversationHandler.END

    await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ user_id –∞–∫–∫–∞—É–Ω—Ç–∞, –∫–æ—Ç–æ—Ä—ã–π –≤—ã —Ö–æ—Ç–∏—Ç–µ –ø–æ–≤—ã—Å–∏—Ç—å –¥–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞.")
    return PROMOTE_USER_ID

# Function to receive the user ID to promote
@reconnect_db
async def receive_user_id(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        target_user_id = int(update.message.text)
    except ValueError:
        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ —á–∏—Å–ª–æ.")
        return PROMOTE_USER_ID

    await set_user_role(target_user_id, 'admin')
    await update.message.reply_text(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {target_user_id} –ø–æ–≤—ã—à–µ–Ω –¥–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞.")
    return ConversationHandler.END

# Function to cancel the conversation
async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("–û—Ç–º–µ–Ω–µ–Ω–æ.")
    return ConversationHandler.END

# Function to generate random missions
@reconnect_db
async def generate_missions():
    missions = []
    cur.execute('SELECT * FROM missions')
    mission_data = cur.fetchall()
    for mission in mission_data:
        if random.randint(1, 100) <= mission['appearing_rate']:
            missions.append(mission)
        if len(missions) >= 5:
            break
    return missions

# Function to handle the /missions command
@reconnect_db
async def missions_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.callback_query.from_user.id
    today = datetime.now().date()

    # Check if user has already attempted 3 missions today
    cur.execute('SELECT attempts FROM mission_attempts WHERE user_id = %s AND date = %s', (user_id, today))
    result = cur.fetchone()
    attempts = result['attempts'] if result else 0

    if attempts >= 3:
        await update.callback_query.edit_message_text("‚ú® –í—ã —É–∂–µ –æ—Ç–ø—Ä–∞–≤–∏–ª–∏ 3 –æ—Ç—Ä—è–¥–∞ –Ω–∞ –º–∏—Å—Å–∏–∏ —Å–µ–≥–æ–¥–Ω—è. ‚åõÔ∏è –ü–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–ø—ã—Ç–∫—É –∑–∞–≤—Ç—Ä–∞. ")
        return

    # Generate 5 random missions based on appearance rates
    missions = await generate_missions()

    # Create buttons for each mission
    buttons = [
        InlineKeyboardButton(
            f"{mission['name']} ({mission['reward']} üíé –∫–∞–º–Ω–µ–π –¥—É—à)",
            callback_data=f"mission_{mission['id']}"
        )
        for mission in missions
    ]
    keyboard = InlineKeyboardMarkup.from_column(buttons)
    await update.callback_query.edit_message_text("‚öîÔ∏è –í—ã–±–µ—Ä–∏—Ç–µ –º–∏—Å—Å–∏—é –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏ –æ—Ç—Ä—è–¥–∞:", reply_markup=keyboard)

# Callback function for mission buttons
@reconnect_db
async def mission_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id
    mission_id = int(query.data.split('_')[1])

    # Fetch mission details using mission_id
    cur.execute('SELECT * FROM missions WHERE id = %s', (mission_id,))
    mission = cur.fetchone()

    if not mission:
        await query.edit_message_text("–û—à–∏–±–∫–∞: –º–∏—Å—Å–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞.")
        return

    # Check if user has already attempted 3 missions today
    today = datetime.now().date()
    cur.execute('SELECT attempts FROM mission_attempts WHERE user_id = %s AND date = %s', (user_id, today))
    result = cur.fetchone()
    attempts = result['attempts'] if result else 0

    if attempts >= 3:
        await query.edit_message_text("‚ú® –í—ã —É–∂–µ –æ—Ç–ø—Ä–∞–≤–∏–ª–∏ 3 –æ—Ç—Ä—è–¥–∞ –Ω–∞ –º–∏—Å—Å–∏–∏ —Å–µ–≥–æ–¥–Ω—è. ‚åõÔ∏è –ü–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–ø—ã—Ç–∫—É –∑–∞–≤—Ç—Ä–∞. ")
        return

    # Increment the number of attempts for today
    if result:
        cur.execute('UPDATE mission_attempts SET attempts = attempts + 1 WHERE user_id = %s AND date = %s', (user_id, today))
    else:
        cur.execute('INSERT INTO mission_attempts (user_id, date, attempts) VALUES (%s, %s, 1)', (user_id, today))
    conn.commit()

    # Calculate mission end time
    start_time = datetime.now()
    end_time = start_time + timedelta(hours=mission['length'])

    # Insert mission into user_missions table
    cur.execute('INSERT INTO user_missions (user_id, mission_id, start_time, end_time) VALUES (%s, %s, %s, %s)', (user_id, mission_id, start_time, end_time))
    conn.commit()

    await query.edit_message_text(f"üíº –í—ã –æ—Ç–ø—Ä–∞–≤–∏–ª–∏ –æ—Ç—Ä—è–¥ –Ω–∞ –º–∏—Å—Å–∏—é: ‚ú®{mission['name']}‚ú®.  üåí –í—Ä–µ–º—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è: ‚åõÔ∏è {end_time.strftime('%Y-%m-%d %H:%M:%S')} ‚åõÔ∏è.")

# Function to check for completed missions
@reconnect_db
async def check_missions(context: ContextTypes.DEFAULT_TYPE):
    now = datetime.now()
    cur.execute('SELECT user_id, mission_id FROM user_missions WHERE completed = FALSE AND end_time <= %s', (now,))
    completed_missions = cur.fetchall()

    for mission in completed_missions:
        user_id, mission_id = mission['user_id'], mission['mission_id']
        cur.execute('SELECT reward FROM missions WHERE id = %s', (mission_id,))
        reward = cur.fetchone()['reward']
        await update_balance(user_id, reward)
        cur.execute('UPDATE user_missions SET completed = TRUE WHERE user_id = %s AND mission_id = %s', (user_id, mission_id))
        await context.bot.send_message(chat_id=user_id, text=f"‚úÖ –í–∞—à–∞ –º–∏—Å—Å–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞! ‚úÖ –í—ã –ø–æ–ª—É—á–∏–ª–∏ {reward} üíé –ö–∞–º–Ω–µ–π –¥—É—à.")
    conn.commit()

# Initialize the bot and add handlers
app = ApplicationBuilder().token("7175746196:AAHckVjmat7IBpqvzWfTxvUzvQR1_1FgLiw").build()

# Conversation handler for promoting a user to admin
conv_handler = ConversationHandler(
    entry_points=[CommandHandler('promote', promote_command)],
    states={
        PROMOTE_USER_ID: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_user_id)],
    },
    fallbacks=[CommandHandler('cancel', cancel)],
)

app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, message_handler))
app.add_handler(CommandHandler("balance", balance_command))
app.add_handler(CommandHandler("checkin", checkin_command))
app.add_handler(CommandHandler("reading", reading_command))
app.add_handler(CommandHandler("rockpaperscissors", rockpaperscissors_command))
app.add_handler(CommandHandler("addbalance", add_balance_command))
app.add_handler(CommandHandler("subbalance", sub_balance_command))
app.add_handler(CommandHandler("setbalance", set_balance_command))
app.add_handler(CommandHandler("missions", missions_command))
app.add_handler(CommandHandler("profile", profile_command))
app.add_handler(conv_handler)
app.add_handler(CallbackQueryHandler(bet_callback, pattern='^bet_'))
app.add_handler(CallbackQueryHandler(play_callback, pattern='^play_'))
app.add_handler(CallbackQueryHandler(mission_callback, pattern='^mission_'))
app.add_handler(CallbackQueryHandler(balance_command, pattern='^balance$'))
app.add_handler(CallbackQueryHandler(reading_command, pattern='^reading$'))
app.add_handler(CallbackQueryHandler(checkin_command, pattern='^checkin$'))
app.add_handler(CallbackQueryHandler(rockpaperscissors_command, pattern='^rockpaperscissors$'))
app.add_handler(CallbackQueryHandler(missions_command, pattern='^missions$'))

job_queue = app.job_queue
job_queue.run_repeating(check_missions, interval=6000, first=6000)

app.run_polling()